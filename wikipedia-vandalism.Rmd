---
title: "Predicting Vandalism on Wikipedia"
author: "Xabriel J Collazo Mojica"
date: "2/14/2022"
output: html_document
bibliography: references.bib
csl: journal-of-the-acm.csl
link-citations: true
notes: footnotes
---

```{r setup, include=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)

#
# Dependencies
#
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(multidplyr)) install.packages("multidplyr", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(doParallel)) install.packages("doParallel", repos = "http://cran.us.r-project.org")
if(!require(MLmetrics)) install.packages("MLmetrics", repos = "http://cran.us.r-project.org")
if(!require(yardstick)) install.packages("yardstick", repos = "http://cran.us.r-project.org")
if(!require(tidytext)) install.packages("tidytext", repos = "http://cran.us.r-project.org")
if(!require(naivebayes)) install.packages("tidytext", repos = "http://cran.us.r-project.org")
if(!require(nnet)) install.packages("nnet", repos = "http://cran.us.r-project.org")

library(tidyverse)
library(multidplyr)
library(caret)
library(doParallel)
library(MLmetrics)
library(yardstick)
library(tidytext)
library(naivebayes)
library(nnet)

# load up helper functions
source("functions.R")

# We utilize "PAN Wikipedia Vandalism Corpus 2010": https://webis.de/data/pan-wvc-10
# download corpus if needed. note the zip file is 438 MBs, and it expands to 1.4 GBs.
if (!dir.exists("data/pan-wikipedia-vandalism-corpus-2010")) {
  dir.create("data/pan-wikipedia-vandalism-corpus-2010")
  corpusFileName <- "data/pan-wikipedia-vandalism-corpus-2010.zip"
  corpusURI <-
    "https://zenodo.org/record/3341488/files/pan-wikipedia-vandalism-corpus-2010.zip?download=1"

  download.file(corpusURI, corpusFileName)
  unzip(corpusFileName, exdir = "data")

  file.remove(corpusFileName)
  rm(corpusFileName, corpusURI)
}
```

## Introduction

(An introduction/overview/executive summary section that describes the dataset and variables, and summarizes the goal of the project and key steps that were performed.)

Wikipedia is a free online encyclopedia that is written and maintained by volunteers. Anyone with internet access can edit Wikipedia. This model has enabled Wikipedia to grow steadily since its inception in 2001 to its current 58 million articles in 325 languages. As of November 2020, Wikipedia is edited 17 million times per month (1.9 edits per second) @Wiki-Wikipedia.

Most of the edits are bona fide contributions. However, about 7% of them are vandalism. Wikipedia defines vandalism as "any change or edit that manipulates content in a way that deliberately compromises Wikipedia's integrity" @Wiki-Vandalism. Vandalism examples include adding out of context profanity, nonsensical additions, removing content without a reason, and adding plausible but false content.

Wikipedia vandalism is handled with manual and automated approaches. In manual approaches, vandalism is removed by the same community of contributors. In severe cases, where vandalism occurs constantly for a particular entry, administrators may enable edit restrictions. Both of these manual approaches slow down the rate of quality contributions since time has to be diverted to clean up existing content.

In automated approaches, software bots have been implemented to detect and correct vandalism. The first iteration of bots used heuristics and regular expressions to detect potential vandalism. The second iteration utilizes more sophisticated approaches. As an example, the "ClueBot NG" bot uses Naive Bayes and Neural Networks to flag vandalism in the English Wikipedia. It catches about 40% of vandalism with its current setting of maximum 0.1% false positive rate @Wiki-User-ClueBotNG. This is the current state of the work.

There has been considerate work done to improve detection [couple cites here]. One of the most interesting approaches is that of @Potthast-2010, in which a competition was held to encourage contributions to the state of the art. We utilize the same dataset as in @Potthast-2010 to implemented a binary classifier that can be compared to the top submissions to their competition.

The dataset is the "PAN Wikipedia Vandalism Corpus 2010". It consists of 32,452 edits on 28,468 English Wikipedia articles, among which 2,391 vandalism edits have been identified @Wiki-Corpus-2010. It reflects the same rate of vandalism as Wikipedia at 7.38%.

The dataset consists of multiple files with metadata about the edits such as a unique identifier, the author of the edit, whether the edit is considered vandalism, among others. It also includes the content of the edited article before and after the edit, and thus we can use existing textual difference algorithms to find the additions and deletions. We discuss the dataset and transformations in more details in the Methods and Analysis section.

Our problem to solve is: given a set of edits of Wikipedia articles, we want to separate the ones we believe to be vandalism, from the ones we believe to not be. This is an imbalanced binary classification. Existing literature suggest that an appropriate method to measure performance is with "Precision-recall curves" (PRC) @Potthast-2010, @Saito-2015. This method allows us to visually compare the trade-off between these metrics, and by calculating the area under the curve of this method (PR-AUC), we can summarize the performance to a single number. This number can be used to choose the best parameters when tuning a model, and to compare models numerically.

We find that by implementing a set of 24 features that rely on the provided dataset without any other external source, we achieve a PR-AUC of \~0.68 with a Random Forest algorithm trained with 1000 trees and 3 random features at each split point. This result is slightly better than the best approach discussed in @Potthast-2010 which yielded \~0.67.

## Methods and Analysis

### PAN Wikipedia Vandalism Corpus 2010

The PAN Wikipedia Vandalism Corpus 2010 consists of 32,452 edits on 28,468 English Wikipedia articles, among which 2,391 vandalism edits have been identified @Wiki-Corpus-2010. It reflects the same rate of vandalism as Wikipedia at 7.3%. There are two files and one directory included in the dataset that are relevant to our work. The first file, `edits.csv`, contains comma separated fields, with each line containing the following:

+-----------------------------------+------------------------------------------------------------------------------------+
| Field                             | Description                                                                        |
+===================================+====================================================================================+
| editid                            | A synthetic unique edit id to easily join this file with others.                   |
+-----------------------------------+------------------------------------------------------------------------------------+
| editor                            | The username for this edit, or an IP address if anonymous.                         |
+-----------------------------------+------------------------------------------------------------------------------------+
| oldrevisionid                     | A Wikipedia unique id for the revision of the article before the edit.             |
+-----------------------------------+------------------------------------------------------------------------------------+
| newrevisionid                     | A Wikipedia unique id for the revision of the article after the edit.              |
+-----------------------------------+------------------------------------------------------------------------------------+
| diffurl                           | a URL pointing to Wikipedia's visual interface for comparing old and new revision. |
+-----------------------------------+------------------------------------------------------------------------------------+
| edittime                          | Timestamp for the edit in ISO 8601 UTC format.                                     |
+-----------------------------------+------------------------------------------------------------------------------------+
| editcomment                       | The comment, if any, that the user left when making the edit.                      |
+-----------------------------------+------------------------------------------------------------------------------------+
| articleid                         | A Wikipedia unique id of the article that this edit modifies.                      |
+-----------------------------------+------------------------------------------------------------------------------------+
| articletitle                      | The title of the edited article.                                                   |
+-----------------------------------+------------------------------------------------------------------------------------+

The second file, `gold-annotations.csv`, contains the following:

+-----------------------------------+------------------------------------------------------------------+
| Field                             | Description                                                      |
+===================================+==================================================================+
| editid                            | References the editid from `edits.csv`.                          |
+-----------------------------------+------------------------------------------------------------------+
| goldclass                         | Classification of the edit as vandalism or regular.              |
+-----------------------------------+------------------------------------------------------------------+
| annotators                        | Number of annotators that concur with the classification         |
+-----------------------------------+------------------------------------------------------------------+
| totalannotators                   | Total number of annotators who reviewed and classified the edit. |
+-----------------------------------+------------------------------------------------------------------+

Finally, there is a directory called `article-revisions/` which @Wiki-Corpus-2010 describes as: "A list of directories `part1/` through `part65/`. Each part directory contains up to 1000 text files, each of which being the revision of a Wikipedia article. The name of a file is its revision identifier, which is referenced in the `edits.csv` file. The contents of each text file is the plain wikitext of the revision."

### Data cleaning

For the rest of this report we use the R programming language and supporting libraries to transform the dataset. A working knowledge of programming and regular expressions is assumed.

The clean up steps for `edits.csv` and `gold-annotations.csv` is trivial: we need only to read and join them by `editid`. We keep the output in an `edits` R data frame object.

Processing `article-revisions/` is more interesting. Our end goal is to calculate what is commonly known as a `diff`; the textual difference between two files. We first define a function `git_diff()` that leverages the built-in diff algorithm from the git version control system[^1]. The key argument to this call is `--word-diff=porcelain`, which makes the output be a line-based format easily consumed by scripts @git-porcelain.

[^1]: We considered multiple approaches for calculating the diff, including using portable code from the `diffobj` R package. However, we found no elegant way to transform the diff into a format amenable to our purposes other than with `git diff`. If the reader is attempting to reproduce our code, we recommend the use of a Unix-like system like Linux or MacOS.

```{r git-diff-definition, eval=FALSE, cache=TRUE}
git_diff <- Vectorize(function(old, new) {
  system2(
    command = "git",
    args = c(
      "diff",
      "--no-prefix",
      "--no-index",
      "--word-diff=porcelain",
      "--unified=0",
      old,
      new
    ),
    stdout = TRUE
  )
})
```

With this function defined, we now walk the `article-revisions/` folder collecting metadata about each revision, and then join this data with `edits`. We then mutate the data frame further by calling `git_diff()` on each pair of 'old' and 'new' revisions, and then we separate the diff output into additions (lines that start with an `+`) and deletions (`-`). Finally, we join the difference calculations into `edits` to consolidate into one object.

```{r load-edits, include=FALSE, cache=TRUE}
#
# Load data
# Below we read both edits.csv and gold-annotations.csv and join them.
#
parentPath <- "data/pan-wikipedia-vandalism-corpus-2010/"

edits <- read_csv(
  file = paste(parentPath, "edits.csv", sep = ""),
  quote = "\"",
  col_names = TRUE,
  col_types = cols(
    editid = col_integer(),
    editor = col_character(),
    oldrevisionid = col_integer(),
    newrevisionid = col_integer(),
    diffurl = col_character(),
    edittime = col_datetime(format = ""),
    editcomment = col_character(),
    articleid = col_integer(),
    articletitle = col_character()
  )
)

annotations <-
  read_csv(
    file = paste(parentPath, "gold-annotations.csv", sep = ""),
    quote = "\"",
    col_names = TRUE,
    col_types = cols(
      editid = col_integer(),
      class = col_character(),
      annotators = col_integer(),
      totalannotators = col_integer()
    )
  ) %>%
  mutate(class = factor(class, levels = c("vandalism", "regular"))) # make sure vandalism == 1

edits <- edits %>%
  left_join(annotations %>% select(editid, class), by = "editid")

rm(annotations)
```

```{r setup-multidplyr, include=FALSE, cache=TRUE}
# use multidplyr to parallelize dplyr actions
cores <- coalesce(detectCores() - 1, 1)
cluster <- multidplyr::new_cluster(cores)
multidplyr::cluster_copy(cluster, 'git_diff')
multidplyr::cluster_library(cluster, 'tidyverse')
edits <- edits %>% partition(cluster)
```

```{r calculate-diffs, cache=TRUE, warning=FALSE}
parentPath <- "data/pan-wikipedia-vandalism-corpus-2010/"

revisionPaths <-
  list.files(
    path = paste(parentPath, "article-revisions", sep = ""),
    full.names = TRUE,
    recursive = TRUE
  )

revisions <- map_dfr(revisionPaths, function(path) {
  list(
    revisionid = as.integer(str_remove(basename(path), ".txt")),
    revisionpath = path,
    # revisionsize = str_length(read_file(path))
    revisionsize = file.size(path)
  )
})

diffs <- edits %>%
  select(editid, oldrevisionid, newrevisionid) %>%
  left_join(
    revisions %>%
      select(revisionid, revisionpath, revisionsize) %>%
      rename(oldrevisionpath = revisionpath, oldrevisionsize = revisionsize),
    by = c("oldrevisionid" = "revisionid"),
    copy = TRUE
  ) %>%
  left_join(
    revisions %>%
      select(revisionid, revisionpath, revisionsize) %>%
      rename(newrevisionpath = revisionpath, newrevisionsize = revisionsize),
    by = c("newrevisionid" = "revisionid"),
    copy = TRUE
  ) %>%
  mutate(diff = git_diff(oldrevisionpath, newrevisionpath)) %>%
  select(editid,
         oldrevisionid,
         newrevisionid,
         oldrevisionsize,
         newrevisionsize,
         diff) %>%
  mutate(additions =
           lapply(diff, function(d) {
             s = d[str_starts(d, fixed("+")) & !str_starts(d, fixed("+++"))]
             str_sub(s, start = 2)
           })) %>%
  mutate(deletions =
           lapply(diff, function(d) {
             s = d[str_starts(d, fixed("-")) & !str_starts(d, fixed("---"))]
             str_sub(s, start = 2)
           }))

edits <- edits %>%
  select(-diffurl) %>%
  left_join(diffs %>% select(-oldrevisionid,-newrevisionid),
            by = c("editid"))
```

```{r, include=FALSE, cache=TRUE}
rm(revisionPaths, parentPath)
rm(diffs, revisions)
```

### Data exploration
As alluded previously, the dataset is highly imbalanced with the `vandalism` class being 7.38% of the data:

```{r imbalance, cache=TRUE}
edits %>% pull(class) %>% table()
```

However, the `vandalism` class does show trends that can drive the classification. Most of the profanities are found in the `vandalism` class:
```{r profanity, cache=TRUE}
# load list of profanities
profanities <- read_lines(file = "data/en/profanities.txt")
# a regex that is aware of wikisyntax
wiki_regex <- "----|:{1,6}|\\*{1,4}|#{1,4}|={1,5}|\\{\\{|\\}\\}|\\[\\[|]]|\\w+"

edits %>%
  collect() %>%
  select(class, additions) %>%
  mutate(
    additions_as_string = map_chr(additions, str_c, collapse = "\n"),
    word_list = map(str_match_all(additions_as_string, wiki_regex), as.vector),
    word_list_lower = map(word_list, str_to_lower),
  ) %>%
  select(class, word_list_lower) %>%
  unnest_longer(col = word_list_lower, values_to = "word") %>%
  mutate(word = replace_na(word, ""),
         is_profanity = map_lgl(word, function(w) {
           bin_search(profanities, w) > 0
         })) %>%
  group_by(class) %>%
  summarise(profanity_rate = sum(is_profanity) / n())
```
Similarly, most of the vandals are anonymous:
```{r vandals-anonymous, cache=TRUE}
# a regex that matches IP addresses
ip_address_regex <- "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"

edits %>%
  collect() %>%
  select(editor, class) %>%
  mutate(is_anonymous = str_detect(editor, ip_address_regex)) %>%
  group_by(class) %>%
  summarise(anonymous_rate = sum(is_anonymous) / n())
```

TODO: Still need to elaborate here.

### Feature selection

The following set of features have been implemented, informed by the work of @Potthast-2010 and @MolaVelasco-2012. Note that all of these features are extracted from the dataset without aid of external sources of information. Unless otherwise noted, these features were extracted from the additions of the diff.

Category | Feature | Description
--------|---------|--------
Character-level | `upper_to_lower_ratio` | The ratio of uppercase characters (`[A-Z]`) to lowercase (`[a-z]`).
Character-level | `upper_to_all_ratio` | The ratio of uppercase characters (`[A-Z]`) to all characters (`.`).
Character-level | `digits_ratio` | The ratio of digits (`\\d`) to all characters (`.`).
Character-level | `special_chars_ratio` | The ratio of special characters (`[^A-Za-z0-9]`) to all characters (`.`).
Character-level | `char_diversity` | The character length of all additions to the (1 / number of different characters ).
Character-level | `compression_ratio` | The ratio of the length of all additions to the length of the compressed version of all additions. We used the `gzip` coder for its speed.
Word-level | `profanity_count` | How many inserted words are considered to be profanities.
Word-level | `pronoun_count` | How many inserted words are pronouns. Ex: He, she, they.
Word-level | `superlative_count` | How many inserted words are superlatives. Ex: biggest, greatest.
Word-level | `contraction_count` | How many inserted words are contractions. Ex: methinks, won't).
Word-level | `wikisyntax_count` | How many inserted words are considered WikiSyntax Ex: "[[", table.
Word-level | `common_vandalism_count` | The top 200 words used by vandals calculated from the train set.
Word-level | `common_regular_count` | The top 200 words used by non-vandals calculated from the train set.
Word-level | `longest_word` | The length of the longest word inserted.
Comment-level | `comment_exists` | Whether the editor included a comment or not.
Comment-level | `comment_length` | The length of the comment if included, otherwise 0.
Comment-level | `comment_is_revert` | Whether the comment content suggests the edit is a revert of a previous edit.
Comment-level | `comment_is_bot` | Whether the comment content suggests the edit was made by a bot.
Comment-level | `comment_has_profanity` | Whether the comment content includes any word considered a profanity.
Size statistic | `size_delta` | The difference between the byte length of the new and old revisions.
Size statistic | `size_ratio` | The ratio between the byte length of the new and old revisions.
Size statistic | `num_additions` | The number of separate additions as derived by the diff algorithm.
Size statistic | `num_deletions` | The number of separate deletions as derived by the diff algorithm.
Editor reputation | `is_anonymous` | Whether the editor is registered on Wikipedia or not.

### Relative effect of each feature
In this section we show the effect of each feature separately.

### Evaluating performance

There are multiple ways to evaluate the performance of a learning algorithm. Tipically, metrics are derived from the confusion matrix. That is, from the four possible predicted conditions: true positive (TP), true negative (TN), false positive (FP), or false negative (TP).

For imbalanced binary classification, a metric like $Accuracy = \frac{TP + TN}{TP + TN + FP +FN}$ can be misleading since we would get a high accuracy if we always predict the majority class. In our case where the `vandalism` class represents only 7.38% of the dataset, accuracy would yield 92.62%.

Additionally, we need a metric that penalizes FP hits, since labeling bona fide contributions as `vandalism` is a particularly bad outcome for a system as Wikipedia that depends on volunteer contributions. Existing literature suggest that an appropriate method for this situation are "Precision-recall curves" (PRC). PRC allows us to visually compare the trade-off between precision and recall, provides visual separation when comparing alternative classifiers, and by calculating the area under the curve of this method (PR-AUC), we can summarize the performance to a single number @Potthast-2010, @Saito-2015.

PRC are calculated as follows: 1) Implement a classification algorithm. 2) Use the algorithm to predict the probability of the 'positive' class (in our case `vandalism`). 3) Now calculate the confusion matrix of the algorithm while varying the threshold $\tau$ of binary classification between [0,1]. 4) Use the confusion matrix at each threshold $\tau$ to calculate the Precision and Recall, and plot the outcome as x and y, respectively.

### Machine Learning Algorithm

(A methods/analysis section that explains the process and techniques used, including data cleaning, data exploration and visualization, any insights gained, and your modeling approach. At least two different models or algorithms must be used, with at least one being more advanced than linear or logistic regression for prediction problems. )

## Results

(A results section that presents the modeling results and discusses the model performance.)

## Conclusion

(A conclusion section that gives a brief summary of the report, its potential impact, its limitations, and future work. )

`r if (knitr::is_html_output()) '## References {-}'`
